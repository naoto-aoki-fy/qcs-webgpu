<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title id="pageTitle">WebGPU Quantum Simulator</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      line-height: 1.5;
      padding: 16px;
      background: #000;
      color: #fff;
    }
    .row {
      margin-bottom: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    input[type="number"], select, button {
      background: #222;
      color: #fff;
      border: 1px solid #555;
    }
    input[type="number"] {
      width: 6ch;
    }
    select, button {
      width: fit-content;
    }
    pre {
      background: #111;
      color: #fff;
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
    }
    canvas { background: #000; }
    .muted { color:#aaa; }
    @media (max-width: 600px) {
      body { padding: 12px; }
      input[type="number"] { width: 6ch; }
      select, button { width: fit-content; }
    }
  </style>
</head>
  <body>
    <h1 id="mainTitle"></h1>
    <div class="row">
      <label id="langLabel" for="langSelect">Language:</label>
      <select id="langSelect">
        <option value="en" selected>English</option>
        <option value="ja">Êó•Êú¨Ë™û</option>
      </select>
    </div>
    <div class="row">
      <label id="numLabel" for="numQubits"></label>
      <input id="numQubits" type="number" min="1" value="3" onfocus="this.select();">
    <label id="precisionLabel">Precision:</label>
    <select id="precision">
    <option value="fp32">FP32</option>
    <option value="fp64">FP64</option>
    </select>
    <button id="runBtn"></button>
  </div>
  <div id="precisionMsg" class="muted"></div>
  <canvas id="runtimeChart"></canvas>
  <div id="summary"></div>
  <pre id="output"></pre>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// Usage: const info = detectViewMode(); console.log(info);
function detectViewMode() {
  const ua = navigator.userAgent || '';
  // Simple UA-based detection (legacy)
  const uaLooksMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(ua);
  // User-Agent Client Hints (more reliable if present)
  const uaData = navigator.userAgentData || null;
  const uaCHMobile = (uaData && ('mobile' in uaData)) ? !!uaData.mobile : null;
  // uaCHMobile === true => browser declares itself "mobile"
  // uaCHMobile === false => browser declares "not mobile" (desktop-like)
  // Viewport/CSS width based (threshold 767px here)
  const viewportWidth = window.innerWidth;
  const viewportLooksMobile = window.matchMedia('(max-width: 767px)').matches;
  // Presence of touch support (reference)
  const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
  // Inference rules (heuristics)
  // - Use UA CH if available.
  // - Otherwise fall back to legacy UA tokens.
  // - If the viewport is narrow, treat it as mobile-like.
  let inferredMobile;
  if (uaCHMobile !== null) inferredMobile = uaCHMobile;
  else inferredMobile = uaLooksMobile;
  // Signal that desktop mode may have been requested
  const likelyRequestedDesktop = (
    (uaCHMobile === false) ||              // UA CH explicitly reports mobile false
    (!uaLooksMobile && uaCHMobile === null && !viewportLooksMobile) // UA looks desktop-like and viewport is wide
  );

  return {
    userAgent: ua,
    uaLooksMobile,
    uaClientHintsMobile: uaCHMobile,
    viewportWidth,
    viewportLooksMobile,
    hasTouch,
    likelyRequestedDesktop
  };
}
</script>
<script type="module">
  const DEBUG = true;
  const UBO_SIZE = 256; // UBO is 256B aligned
  let currentLang = 'en';
  const isMobile = !detectViewMode().likelyRequestedDesktop;

  const translations = {
    ja: {
      pageTitle: 'WebGPU ÈáèÂ≠ê„Ç∑„Éü„É•„É¨„Éº„Çø',
      mainTitle: 'WebGPU ÈáèÂ≠ê„Ç∑„Éü„É•„É¨„Éº„Çø',
      langLabel: 'Language:',
      numQubitsLabel: 'ÈáèÂ≠ê„Éì„ÉÉ„ÉàÊï∞:',
      precisionLabel: 'Á≤æÂ∫¶:',
      runBtn: 'ÂÆüË°å',
      chartXLabel: 'ÈáèÂ≠ê„Éì„ÉÉ„ÉàÊï∞',
      chartYLabel: 'Âá¶ÁêÜÊôÇÈñì (ms)',
      notSupported: '„Åì„ÅÆ„Éñ„É©„Ç¶„Ç∂„ÅØ WebGPU „Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇChrome/Edge 125+ „Å™„Å©„Åß„ÅäË©¶„Åó„Åè„Å†„Åï„ÅÑ„ÄÇ',
      adapterError: 'GPU adapter „ÇíÂèñÂæó„Åß„Åç„Åæ„Åõ„Çì„Åß„Åó„Åü„ÄÇ',
      fp64NotSupportedError: "„Åì„ÅÆ„Éá„Éê„Ç§„Çπ„ÅØ fp64 „Çí„Çµ„Éù„Éº„Éà„Åó„Å¶„ÅÑ„Åæ„Åõ„Çì„ÄÇ",
      deviceLimitExceeded: (numQubits, maxQFromBinding) => `num_qubits=${numQubits} „ÅØ„Éá„Éê„Ç§„ÇπÂà∂ÈôêÔºà~${maxQFromBinding}Ôºâ„ÇíË∂Ö„Åà„Å¶„ÅÑ„Åæ„Åô„ÄÇ`,
      summary: (n, Nstates, amp0Re, amp0Im, amp1Re, amp1Im, norm, simMs, invSqrt2) =>
        `<div>n = <b>${n}</b>ÔºàÁä∂ÊÖãÊï∞: 2<sup>${n}</sup> = ${Nstates}Ôºâ</div>
         <div>‚ü®0‚Ä¶0|œà‚ü© = ${amp0Re.toFixed(6)} ${(amp0Im>=0?'+':'‚àí')} ${Math.abs(amp0Im).toFixed(6)}i,
              ‚ü®1‚Ä¶1|œà‚ü© = ${amp1Re.toFixed(6)} ${(amp1Im>=0?'+':'‚àí')} ${Math.abs(amp1Im).toFixed(6)}i
              ÔºàÊúüÂæÖ ~ ${invSqrt2}Ôºâ</div>
         <div>ÂêàË®àÂá¶ÁêÜÊôÇÈñì: <b>${simMs.toFixed(2)} ms</b></div>`,
      vecHeader: '[Áä∂ÊÖã„Éô„ÇØ„Éà„É´Ôºàindex: re + i¬∑imÔºâ]',
      nonzeroHeader: (threshold, count) => `[Èùû„Çº„É≠Ôºà„Åó„Åç„ÅÑÂÄ§ ${threshold}Ôºâ: ${count} ÂÄã]`,
      omitted: count => `‚Ä¶ ÁúÅÁï•ÔºàÂêàË®à ${count} ÂÄãÔºâ`,
    },
    en: {
      pageTitle: 'WebGPU Quantum Simulator',
      mainTitle: 'WebGPU Quantum Simulator',
      langLabel: 'Language:',
      numQubitsLabel: 'Number of qubits:',
      precisionLabel: 'Precision:',
      runBtn: 'Run',
      chartXLabel: 'Number of qubits',
      chartYLabel: 'Runtime (ms)',
      notSupported: 'This browser does not support WebGPU. Please try Chrome/Edge 125+.',
      fp64NotSupportedError: "This device does not support fp64.",
      adapterError: 'Failed to get GPU adapter.',
      deviceLimitExceeded: (numQubits, maxQFromBinding) => `num_qubits=${numQubits} exceeds device limit (~${maxQFromBinding}).`,
      summary: (n, Nstates, amp0Re, amp0Im, amp1Re, amp1Im, norm, simMs, invSqrt2) =>
        `<div>n = <b>${n}</b> (number of states: 2<sup>${n}</sup> = ${Nstates})</div>
         <div>‚ü®0‚Ä¶0|œà‚ü© = ${amp0Re.toFixed(6)} ${(amp0Im>=0?'+':'-')} ${Math.abs(amp0Im).toFixed(6)}i,
              ‚ü®1‚Ä¶1|œà‚ü© = ${amp1Re.toFixed(6)} ${(amp1Im>=0?'+':'-')} ${Math.abs(amp1Im).toFixed(6)}i
              (expected ~ ${invSqrt2})</div>
         <div>Total runtime: <b>${simMs.toFixed(2)} ms</b></div>`,
      vecHeader: '[State vector (index: re + i¬∑im)]',
      nonzeroHeader: (threshold, count) => `[Non-zero (threshold ${threshold}): ${count} entries]`,
      omitted: count => `... omitted (total ${count} entries)`,
    }
  };

  let runtimeChart;

    function initChart(t) {
      const ctx = document.getElementById('runtimeChart');
      runtimeChart = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            label: 'Runtime',
            data: [],
            borderColor: '#0ff',
            backgroundColor: '#0ff'
          }]
        },
        options: {
          scales: {
            x: {
              title: { display: true, text: t.chartXLabel, color: '#fff' },
              type: 'linear',
              ticks: { color: '#fff' },
              grid: { color: '#444' }
            },
            y: {
              title: { display: true, text: t.chartYLabel, color: '#fff' },
              ticks: { color: '#fff' },
              grid: { color: '#444' }
            }
          },
          plugins: {
            legend: { labels: { color: '#fff' } }
          }
        }
      });
    }

  function addDataPoint(numQubits, timeMs) {
    if (!runtimeChart) return;
    runtimeChart.data.datasets[0].data.push({ x: numQubits, y: timeMs });
    runtimeChart.update();
  }

  async function updateNumQubitOptions() {
    const sel = document.getElementById('numQubits');
    if (!sel || sel.tagName !== 'SELECT') return;
    sel.innerHTML = '';
    let maxQ = 10;
    if (navigator.gpu) {
      const precision = document.getElementById('precision').value;
      const is64 = (precision === 'fp64');
      const bytesPerAmp = is64 ? 16 : 8;
      const adapter = await navigator.gpu.requestAdapter();
      if (adapter) {
        const device = await adapter.requestDevice(is64 ? { requiredFeatures: ['shader-f64'] } : {});
        const maxBindBytes = device.limits.maxStorageBufferBindingSize ?? (128 * 1024 * 1024);
        maxQ = Math.floor(Math.log2(maxBindBytes / bytesPerAmp));
      }
    }
    for (let q = 1; q <= maxQ; q++) {
      const opt = document.createElement('option');
      opt.value = q;
      opt.textContent = q;
      if (q === 3) opt.selected = true;
      sel.appendChild(opt);
    }
  }

  function setupMobileQubitSelect() {
    const numInput = document.getElementById('numQubits');
    if (!numInput) return;
    const sel = document.createElement('select');
    sel.id = 'numQubits';
    numInput.parentNode.replaceChild(sel, numInput);
    updateNumQubitOptions();
  }

  function setLanguage(lang) {
    currentLang = lang;
    document.getElementById("langSelect").value = lang;
    const t = translations[lang];
    document.title = t.pageTitle;
    document.getElementById('mainTitle').textContent = t.mainTitle;
    document.getElementById('langLabel').textContent = t.langLabel;
    document.getElementById('numLabel').innerHTML = t.numQubitsLabel;
    document.getElementById('precisionLabel').innerHTML = t.precisionLabel;
    document.getElementById('runBtn').textContent = t.runBtn;
    document.getElementById('summary').textContent = '';
    document.getElementById('output').textContent = '';
    document.getElementById('precisionMsg').textContent = '';
    if (!runtimeChart) {
      initChart(t);
    } else {
      runtimeChart.options.scales.x.title.text = t.chartXLabel;
      runtimeChart.options.scales.y.title.text = t.chartYLabel;
      runtimeChart.update();
    }
  }

window.addEventListener("error", (e)=>console.error("Window error:", e.error || e.message));

  async function main(numQubits, precision) {
    const out = document.getElementById("output");
    const summary = document.getElementById("summary");
    out.textContent = "";
    summary.textContent = "";
    const t = translations[currentLang];

    const is64 = (precision === "fp64");
    const floatArray = is64 ? Float64Array : Float32Array;
      if (!navigator.gpu) {
        out.textContent = t.notSupported;
        return;
      }

  const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) { out.textContent = t.adapterError; return; }
  if (is64 && !adapter.features.has("shader-f64")) {
    out.textContent = t.fp64NotSupportedError;
    return;
  }
  const device  = await adapter.requestDevice(is64 ? { requiredFeatures: ["shader-f64"] } : {});
  device.onuncapturederror = (e)=>console.error("Uncaptured GPU error:", e.error);

  console.groupCollapsed("üîß Device Info");
  console.log("Adapter:", adapter);
  console.log("Device Limits:", device.limits);
  console.log("Features:", [...device.features.values()]);
  console.groupEnd();

  const Nstates = 2 ** numQubits;
  const bytesPerAmp = is64 ? 16 : 8; // complex128 or complex64
  const stateBytes  = Nstates * bytesPerAmp;

  const maxBindBytes = device.limits.maxStorageBufferBindingSize ?? (128 * 1024 * 1024);
  const maxQFromBinding = Math.floor(Math.log2(maxBindBytes / bytesPerAmp));
  if (numQubits > maxQFromBinding) {
      out.textContent = t.deviceLimitExceeded(numQubits, maxQFromBinding);
      return;
    }

  console.groupCollapsed("üìê Config");
  console.table({ numQubits, Nstates, stateBytes, maxStorageBufferBindingSize: maxBindBytes, maxQFromBinding });
  console.groupEnd();

  const WG_SIZE = Math.min(256, device.limits.maxComputeInvocationsPerWorkgroup);
  const numPairs = Nstates >>> 1;
  const numWorkgroups = Math.ceil(numPairs / WG_SIZE);

  console.groupCollapsed("üßµ Workgroups");
  console.table({ WG_SIZE, numPairs, numWorkgroups });
  console.groupEnd();

  // --- State vector (ping-pong) ---
  const initHost = new floatArray(Nstates * 2);
  initHost[0] = 1.0;

  const stateA = device.createBuffer({
    size: stateBytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
    mappedAtCreation: true
  });
  new floatArray(stateA.getMappedRange()).set(initHost);
  stateA.unmap();

  const stateB = device.createBuffer({
    size: stateBytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
  });

  const readback = device.createBuffer({
    size: stateBytes, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  });

    // --- WGSL (supports FP32/FP64 switching) ---
  const scalar = is64 ? "f64" : "f32";
  const complexField = is64 ? `vec2<${scalar}>` : `vec4<${scalar}>`;
  const access = is64 ? "" : ".xy";

  const singleQubitWGSL = /* wgsl */`
struct GateU {
  stride : u32,   // 2^target
  npairs : u32,   // N/2
  _pad0  : u32,
  _pad1  : u32,
  a : ${complexField},${is64 ? "" : "  // [re, im, 0, 0]"}
  b : ${complexField},
  c : ${complexField},
  d : ${complexField},
};

struct Buf { data: array<${scalar}>, };

@group(0) @binding(0) var<storage, read>       stateIn  : Buf;
@group(0) @binding(1) var<storage, read_write> stateOut : Buf;
@group(0) @binding(2) var<uniform>             U       : GateU;

fn cmul(x: vec2<${scalar}>, y: vec2<${scalar}>) -> vec2<${scalar}> {
  return vec2<${scalar}>(x.x*y.x - x.y*y.y, x.x*y.y + x.y*x.x);
}

@compute @workgroup_size(${WG_SIZE})
fn main(@builtin(global_invocation_id) gid : vec3<u32>) {
  let k = gid.x;
  if (k >= U.npairs) { return; }

  let s = U.stride;
  let block = (k / s) * (2u * s);
  let i0    = block + (k % s);
  let i1    = i0 + s;

  let f0 = i0 * 2u;
  let f1 = i1 * 2u;

  let v0 = vec2<${scalar}>(stateIn.data[f0],    stateIn.data[f0+1u]);
  let v1 = vec2<${scalar}>(stateIn.data[f1],    stateIn.data[f1+1u]);

  let a = U.a${access};
  let b = U.b${access};
  let c = U.c${access};
  let d = U.d${access};

  let o0 = cmul(a, v0) + cmul(b, v1);
  let o1 = cmul(c, v0) + cmul(d, v1);

  stateOut.data[f0]    = o0.x;
  stateOut.data[f0+1u] = o0.y;
  stateOut.data[f1]    = o1.x;
  stateOut.data[f1+1u] = o1.y;
}
`;

  const cnotWGSL = /* wgsl */`
struct CNOTU {
  stride      : u32, // 2^target
  npairs      : u32, // N/2
  controlMask : u32, // 2^control
  _pad        : u32,
};

struct Buf { data: array<${scalar}>, };

@group(0) @binding(0) var<storage, read>       stateIn  : Buf;
@group(0) @binding(1) var<storage, read_write> stateOut : Buf;
@group(0) @binding(2) var<uniform>             U       : CNOTU;

@compute @workgroup_size(${WG_SIZE})
fn main(@builtin(global_invocation_id) gid : vec3<u32>) {
  let k = gid.x;
  if (k >= U.npairs) { return; }

  let s = U.stride;
  let block = (k / s) * (2u * s);
  let i0    = block + (k % s);
  let i1    = i0 + s;

  let f0 = i0 * 2u;
  let f1 = i1 * 2u;

  if ((i0 & U.controlMask) != 0u) {
    // swap
    stateOut.data[f0]    = stateIn.data[f1];
    stateOut.data[f0+1u] = stateIn.data[f1+1u];
    stateOut.data[f1]    = stateIn.data[f0];
    stateOut.data[f1+1u] = stateIn.data[f0+1u];
  } else {
    // copy
    stateOut.data[f0]    = stateIn.data[f0];
    stateOut.data[f0+1u] = stateIn.data[f0+1u];
    stateOut.data[f1]    = stateIn.data[f1];
    stateOut.data[f1+1u] = stateIn.data[f1+1u];
  }
}
`;
const singlePipe = device.createComputePipeline({
    layout: "auto", compute: { module: device.createShaderModule({ code: singleQubitWGSL }), entryPoint: "main" }
  });
  const cnotPipe = device.createComputePipeline({
    layout: "auto", compute: { module: device.createShaderModule({ code: cnotWGSL }), entryPoint: "main" }
  });

  // --- UBO helpers (FIX: include COPY_DST in usage) ---
  function createUBOWithData(arrayBuffer) {
    const ubo = device.createBuffer({
      size: UBO_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(ubo, 0, arrayBuffer);
    return ubo;
  }

  function buildSingleUBOData(target, N, mat) {
    const buf = new ArrayBuffer(UBO_SIZE);
    const dv  = new DataView(buf);
    const stride = 1 << target;
    const npairs = N >>> 1;

    dv.setUint32(0,  stride, true);
    dv.setUint32(4,  npairs, true);
    dv.setUint32(8,  0, true);
    dv.setUint32(12, 0, true);

    if (is64) {
      const f64 = new Float64Array(buf);
      let base = 16 / 8;
      f64[base+0] = mat.a[0]; f64[base+1] = mat.a[1];
      f64[base+2] = mat.b[0]; f64[base+3] = mat.b[1];
      f64[base+4] = mat.c[0]; f64[base+5] = mat.c[1];
      f64[base+6] = mat.d[0]; f64[base+7] = mat.d[1];
    } else {
      const f32 = new Float32Array(buf);
      let base = 16 / 4; // float index
      // a,b,c,d (re,im in xy / zw=0)
      f32[base+0]  = mat.a[0]; f32[base+1]  = mat.a[1];
      f32[base+4]  = mat.b[0]; f32[base+5]  = mat.b[1];
      f32[base+8]  = mat.c[0]; f32[base+9]  = mat.c[1];
      f32[base+12] = mat.d[0]; f32[base+13] = mat.d[1];
    }

    return { buf, stride, npairs };
  }

  function buildCNOTUBOData(control, target, N) {
    const buf = new ArrayBuffer(UBO_SIZE);
    const dv  = new DataView(buf);
    const stride = 1 << target;
    const npairs = N >>> 1;
    const controlMask = 1 << control;

    dv.setUint32(0,  stride, true);
    dv.setUint32(4,  npairs, true);
    dv.setUint32(8,  controlMask, true);
    dv.setUint32(12, 0, true);

    return { buf, stride, npairs, controlMask };
  }

  // --- Dump (FIX: always pass the result buffer) ---
  async function dumpState(srcBuf, label, maxShow = 8) {
    const enc = device.createCommandEncoder();
    enc.copyBufferToBuffer(srcBuf, 0, readback, 0, stateBytes);
    device.queue.submit([enc.finish()]);
    await device.queue.onSubmittedWorkDone();

    await readback.mapAsync(GPUMapMode.READ);
    const arr = new floatArray(readback.getMappedRange()).slice();
    readback.unmap();

    let norm = 0, nonzero = 0;
    for (let i = 0; i < arr.length; i += 2) {
      const re = arr[i], im = arr[i+1];
      const p = re*re + im*im;
      norm += p;
      if (p > 1e-7) nonzero++;
    }
    const amp0 = [arr[0], arr[1]];
    const lastIdx = (Nstates - 1) * 2;
    const amp1 = [arr[lastIdx], arr[lastIdx + 1]];

    console.groupCollapsed(`üß™ ${label}`);
    console.log(`|0‚Ä¶0‚ü© amp: ${fmtC(amp0[0], amp0[1])}, |1‚Ä¶1‚ü© amp: ${fmtC(amp1[0], amp1[1])}`);
    console.log(`norm: ${norm.toFixed(8)}, nonzero amplitudes: ${nonzero}`);
    const preview = [];
    for (let i = 0; i < Math.min(Nstates, maxShow); i++) {
      preview.push({ i, bin: padBin(i, numQubits), re: arr[2*i].toFixed(6), im: arr[2*i+1].toFixed(6) });
    }
    console.table(preview);
    console.groupEnd();

    return arr;
  }
  function fmtC(re, im) { const s = im>=0?"+":"‚àí"; return `${re.toFixed(6)} ${s} ${Math.abs(im).toFixed(6)}i`; }
  function padBin(i, n) { return (i>>>0).toString(2).padStart(n,"0"); }

  (function logPairMappingSample() {
    const t = 0, s = 1 << t;
    const preview = [];
    for (let k = 0; k < Math.min(8, numPairs); k++) {
      const block = Math.floor(k / s) * (2 * s);
      const i0 = block + (k % s);
      const i1 = i0 + s;
      preview.push({ k, i0, i1, i0bin: padBin(i0, numQubits), i1bin: padBin(i1, numQubits) });
    }
    console.groupCollapsed("üîé Pair mapping sample (target=0)");
    console.table(preview);
    console.groupEnd();
  })();

  let bufIn  = stateA;
  let bufOut = stateB;

  const INV_SQRT2 = 1/Math.sqrt(2);
  const H = { a:[+INV_SQRT2,0], b:[+INV_SQRT2,0], c:[+INV_SQRT2,0], d:[-INV_SQRT2,0] };

  // ‚òÖ Start timing the simulation section here
  const simT0 = performance.now();               // ‚Üê added
  console.time("‚è±Ô∏è Simulation total");

  // --- H on qubit 0 ---
  {
    console.time("H gate");
    const { buf: uboData, stride, npairs } = buildSingleUBOData(0, Nstates, H);
    console.groupCollapsed("UBO(H) header/matrix");
    console.table({ stride, npairs, a:H.a.join(","), b:H.b.join(","), c:H.c.join(","), d:H.d.join(",") });
    console.groupEnd();

    const ubo = createUBOWithData(uboData);

    device.pushErrorScope("validation");
    const enc = device.createCommandEncoder();
    const pass = enc.beginComputePass();
    pass.setPipeline(singlePipe);
    const bind = device.createBindGroup({
      layout: singlePipe.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: bufIn  } },
        { binding: 1, resource: { buffer: bufOut } },
        { binding: 2, resource: { buffer: ubo    } },
      ]
    });
    pass.setBindGroup(0, bind);
    pass.dispatchWorkgroups(numWorkgroups);
    pass.end();
    device.queue.submit([enc.finish()]);
    const err = await device.popErrorScope();
    if (err) console.error("Validation error (H):", err);
    await device.queue.onSubmittedWorkDone();

    if (DEBUG) await dumpState(bufOut, "After H"); // ‚Üê FIX: pass the result buffer
    console.timeEnd("H gate");
    [bufIn, bufOut] = [bufOut, bufIn];
  }

  // --- CNOT(0‚Üíi), i=1..n-1 ---
  for (let t = 1; t < numQubits; t++) {
    console.time(`CNOT 0‚Üí${t}`);
    const { buf: uboData, stride, npairs, controlMask } = buildCNOTUBOData(0, t, Nstates);
    console.groupCollapsed(`UBO(CNOT 0‚Üí${t})`);
    console.table({ stride, npairs, controlMask });
    console.groupEnd();

    const ubo = createUBOWithData(uboData);

    device.pushErrorScope("validation");
    const enc = device.createCommandEncoder();
    const pass = enc.beginComputePass();
    pass.setPipeline(cnotPipe);
    const bind = device.createBindGroup({
      layout: cnotPipe.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: bufIn  } },
        { binding: 1, resource: { buffer: bufOut } },
        { binding: 2, resource: { buffer: ubo    } },
      ]
    });
    pass.setBindGroup(0, bind);
    pass.dispatchWorkgroups(numWorkgroups);
    pass.end();
    device.queue.submit([enc.finish()]);
    const err = await device.popErrorScope();
    if (err) console.error(`Validation error (CNOT 0‚Üí${t}):`, err);
    await device.queue.onSubmittedWorkDone();

    if (DEBUG) await dumpState(bufOut, `After CNOT 0‚Üí${t}`); // ‚Üê FIX
    console.timeEnd(`CNOT 0‚Üí${t}`);
    [bufIn, bufOut] = [bufOut, bufIn];
  }

  console.timeEnd("‚è±Ô∏è Simulation total");
  const simElapsedMs = performance.now() - simT0;   // ‚òÖ Total processing time (for display)

  // --- Final readback to page ---
  const encFinal = device.createCommandEncoder();
  encFinal.copyBufferToBuffer(bufIn, 0, readback, 0, stateBytes);
  device.queue.submit([encFinal.finish()]);
  await device.queue.onSubmittedWorkDone();
  await readback.mapAsync(GPUMapMode.READ);
  const result = new floatArray(readback.getMappedRange()).slice();
  readback.unmap();

  let norm = 0;
  for (let i = 0; i < result.length; i += 2) {
    const re = result[i], im = result[i+1];
    norm += re*re + im*im;
  }
  const amp0Re = result[0], amp0Im = result[1];
  const lastIdx = (Nstates - 1) * 2;
  const amp1Re = result[lastIdx], amp1Im = result[lastIdx + 1];

  const INV_SQRT2_STR = (1/Math.sqrt(2)).toFixed(6);
    summary.innerHTML = t.summary(numQubits, Nstates, amp0Re, amp0Im, amp1Re, amp1Im, norm, simElapsedMs, INV_SQRT2_STR);
    addDataPoint(numQubits, simElapsedMs);
    //  <div class="muted">Check the console (DevTools) for details.</div>

  const lines = [];
  if (numQubits <= 12) {
      lines.push(t.vecHeader);
    for (let i = 0; i < Nstates; i++) {
      lines.push(`${padBin(i, numQubits)} (${i.toString().padStart(4)}) : ` +
                 `${result[2*i].toFixed(6)} + ${result[2*i+1].toFixed(6)}i`);
    }
  } else {
    const threshold = 1e-5;
    const nonzeros = [];
    for (let i = 0; i < Nstates; i++) {
      const re = result[2*i], im = result[2*i+1];
      if (re*re + im*im > threshold*threshold) nonzeros.push([i, re, im]);
    }
      lines.push(t.nonzeroHeader(threshold, nonzeros.length));
    for (const [i, re, im] of nonzeros.slice(0, 32)) {
      lines.push(`${padBin(i, numQubits)} (${i}): ${re.toFixed(6)} + ${im.toFixed(6)}i`);
    }
      if (nonzeros.length > 32) lines.push(t.omitted(nonzeros.length));
    }
  out.textContent = lines.join("\n");
}

/* UI */
  document.getElementById("langSelect").addEventListener("change", (e) => {
    setLanguage(e.target.value);
  });
  if (navigator.language == "ja") {
    setLanguage('ja');
  } else {
    setLanguage('en');
  }
  document.getElementById("precision").addEventListener("change", async (e) => {
    const msg = document.getElementById("precisionMsg");
    msg.textContent = "";
    if (e.target.value === "fp64") {
      const t = translations[currentLang];
      if (!navigator.gpu) {
        msg.textContent = t.notSupported;
        e.target.value = "fp32";
      } else {
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          msg.textContent = t.adapterError;
          e.target.value = "fp32";
        } else if (!adapter.features.has("shader-f64")) {
          msg.textContent = t.fp64NotSupportedError;
          e.target.value = "fp32";
        }
      }
    }
    if (isMobile) updateNumQubitOptions();
  });
  if (isMobile) {
    setupMobileQubitSelect();
  }
  document.getElementById("runBtn").addEventListener("click", async () => {
    document.getElementById("precisionMsg").textContent = "";
    const n = parseInt(document.getElementById("numQubits").value, 10);
    const precision = document.getElementById("precision").value;
    await main(n, precision);
  });

  // ‚òÖ Stop automatic execution (delete the following line)
  // main(parseInt(document.getElementById("numQubits").value, 10));
  </script>
  </body>
  </html>
