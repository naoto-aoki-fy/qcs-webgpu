<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title id="pageTitle">WebGPU Quantum Simulator</title>
  <style>
    body {
      font-family: system-ui, sans-serif;
      line-height: 1.5;
      padding: 16px;
      background: #000;
      color: #fff;
    }
    .row {
      margin-bottom: 12px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      align-items: center;
    }
    input[type="number"], select, button {
      background: #222;
      color: #fff;
      border: 1px solid #555;
    }
    input[type="number"] {
      width: 6ch;
    }
    select, button {
      width: fit-content;
    }
    pre {
      background: #111;
      color: #fff;
      padding: 12px;
      border-radius: 6px;
      overflow-x: auto;
    }
    canvas { background: #000; }
    .muted { color:#aaa; }
    @media (max-width: 600px) {
      body { padding: 12px; }
      input[type="number"] { width: 6ch; }
      select, button { width: fit-content; }
    }
  </style>
</head>
  <body>
    <h1 id="mainTitle"></h1>
    <div class="row">
      <label id="langLabel" for="langSelect">Language:</label>
      <select id="langSelect">
        <option value="en" selected>English</option>
        <option value="ja">日本語</option>
      </select>
    </div>
    <div class="row">
      <label id="numLabel" for="numQubits"></label>
      <input id="numQubits" type="number" min="1" value="3" onfocus="this.select();">
    <label id="precisionLabel">Precision:</label>
    <select id="precision">
    <option value="fp32">FP32</option>
    <option value="fp64">FP64</option>
    </select>
    <button id="runBtn"></button>
  </div>
  <div id="precisionMsg" class="muted"></div>
  <canvas id="runtimeChart"></canvas>
  <div id="summary"></div>
  <pre id="output"></pre>

<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
// Usage: const info = detectViewMode(); console.log(info);
function detectViewMode() {
  const ua = navigator.userAgent || '';
  // Simple UA-based detection (legacy)
  const uaLooksMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(ua);
  // User-Agent Client Hints (more reliable if present)
  const uaData = navigator.userAgentData || null;
  const uaCHMobile = (uaData && ('mobile' in uaData)) ? !!uaData.mobile : null;
  // uaCHMobile === true => browser declares itself "mobile"
  // uaCHMobile === false => browser declares "not mobile" (desktop-like)
  // Viewport/CSS width based (threshold 767px here)
  const viewportWidth = window.innerWidth;
  const viewportLooksMobile = window.matchMedia('(max-width: 767px)').matches;
  // Presence of touch support (reference)
  const hasTouch = ('ontouchstart' in window) || (navigator.maxTouchPoints && navigator.maxTouchPoints > 0);
  // Inference rules (heuristics)
  // - Use UA CH if available.
  // - Otherwise fall back to legacy UA tokens.
  // - If the viewport is narrow, treat it as mobile-like.
  let inferredMobile;
  if (uaCHMobile !== null) inferredMobile = uaCHMobile;
  else inferredMobile = uaLooksMobile;
  // Signal that desktop mode may have been requested
  const likelyRequestedDesktop = (
    (uaCHMobile === false) ||              // UA CH explicitly reports mobile false
    (!uaLooksMobile && uaCHMobile === null && !viewportLooksMobile) // UA looks desktop-like and viewport is wide
  );

  return {
    userAgent: ua,
    uaLooksMobile,
    uaClientHintsMobile: uaCHMobile,
    viewportWidth,
    viewportLooksMobile,
    hasTouch,
    likelyRequestedDesktop
  };
}
</script>
<script type="module">
import { getWGSL, buildSingleUBOData, buildCNOTUBOData, createUBOWithData } from './ghz-lib.js';
  const DEBUG = true;
  let currentLang = 'en';
  const isMobile = !detectViewMode().likelyRequestedDesktop;

  const translations = {
    ja: {
      pageTitle: 'WebGPU 量子シミュレータ',
      mainTitle: 'WebGPU 量子シミュレータ',
      langLabel: 'Language:',
      numQubitsLabel: '量子ビット数:',
      precisionLabel: '精度:',
      runBtn: '実行',
      running: '計算中...',
      chartXLabel: '量子ビット数',
      chartYLabel: '処理時間 (ms)',
      notSupported: 'このブラウザは WebGPU をサポートしていません。Chrome/Edge 125+ などでお試しください。',
      adapterError: 'GPU adapter を取得できませんでした。',
      fp64NotSupportedError: "このデバイスは fp64 をサポートしていません。",
      deviceLimitExceeded: (numQubits, maxQFromBinding) => `num_qubits=${numQubits} はデバイス制限（~${maxQFromBinding}）を超えています。`,
      summary: (n, Nstates, amp0Re, amp0Im, amp1Re, amp1Im, norm, simMs, invSqrt2) =>
        `<div>n = <b>${n}</b>（状態数: 2<sup>${n}</sup> = ${Nstates}）</div>
         <div>⟨0…0|ψ⟩ = ${amp0Re.toFixed(6)} ${(amp0Im>=0?'+':'−')} ${Math.abs(amp0Im).toFixed(6)}i,
              ⟨1…1|ψ⟩ = ${amp1Re.toFixed(6)} ${(amp1Im>=0?'+':'−')} ${Math.abs(amp1Im).toFixed(6)}i
              （期待 ~ ${invSqrt2}）</div>
         <div>合計処理時間: <b>${simMs.toFixed(2)} ms</b></div>`,
      vecHeader: '[状態ベクトル（index: re + i·im）]',
      nonzeroHeader: (threshold, count) => `[非ゼロ（しきい値 ${threshold}）: ${count} 個]`,
      omitted: count => `… 省略（合計 ${count} 個）`,
    },
    en: {
      pageTitle: 'WebGPU Quantum Simulator',
      mainTitle: 'WebGPU Quantum Simulator',
      langLabel: 'Language:',
      numQubitsLabel: 'Number of qubits:',
      precisionLabel: 'Precision:',
      runBtn: 'Run',
      running: 'Calculating...',
      chartXLabel: 'Number of qubits',
      chartYLabel: 'Runtime (ms)',
      notSupported: 'This browser does not support WebGPU. Please try Chrome/Edge 125+.',
      fp64NotSupportedError: "This device does not support fp64.",
      adapterError: 'Failed to get GPU adapter.',
      deviceLimitExceeded: (numQubits, maxQFromBinding) => `num_qubits=${numQubits} exceeds device limit (~${maxQFromBinding}).`,
      summary: (n, Nstates, amp0Re, amp0Im, amp1Re, amp1Im, norm, simMs, invSqrt2) =>
        `<div>n = <b>${n}</b> (number of states: 2<sup>${n}</sup> = ${Nstates})</div>
         <div>⟨0…0|ψ⟩ = ${amp0Re.toFixed(6)} ${(amp0Im>=0?'+':'-')} ${Math.abs(amp0Im).toFixed(6)}i,
              ⟨1…1|ψ⟩ = ${amp1Re.toFixed(6)} ${(amp1Im>=0?'+':'-')} ${Math.abs(amp1Im).toFixed(6)}i
              (expected ~ ${invSqrt2})</div>
         <div>Total runtime: <b>${simMs.toFixed(2)} ms</b></div>`,
      vecHeader: '[State vector (index: re + i·im)]',
      nonzeroHeader: (threshold, count) => `[Non-zero (threshold ${threshold}): ${count} entries]`,
      omitted: count => `... omitted (total ${count} entries)`,
    }
  };

  let runtimeChart;

    function initChart(t) {
      const ctx = document.getElementById('runtimeChart');
      runtimeChart = new Chart(ctx, {
        type: 'scatter',
        data: {
          datasets: [{
            label: 'Runtime',
            data: [],
            borderColor: '#0ff',
            backgroundColor: '#0ff'
          }]
        },
        options: {
          scales: {
            x: {
              title: { display: true, text: t.chartXLabel, color: '#fff' },
              type: 'linear',
              ticks: { color: '#fff' },
              grid: { color: '#444' }
            },
            y: {
              title: { display: true, text: t.chartYLabel, color: '#fff' },
              ticks: { color: '#fff' },
              grid: { color: '#444' }
            }
          },
          plugins: {
            legend: { labels: { color: '#fff' } }
          }
        }
      });
    }

  function addDataPoint(numQubits, timeMs) {
    if (!runtimeChart) return;
    runtimeChart.data.datasets[0].data.push({ x: numQubits, y: timeMs });
    runtimeChart.update();
  }

  async function updateNumQubitOptions() {
    const sel = document.getElementById('numQubits');
    if (!sel || sel.tagName !== 'SELECT') return;
    sel.innerHTML = '';
    let maxQ = 10;
    if (navigator.gpu) {
      const precision = document.getElementById('precision').value;
      const is64 = (precision === 'fp64');
      const bytesPerAmp = is64 ? 16 : 8;
      const adapter = await navigator.gpu.requestAdapter();
      if (adapter) {
        const device = await adapter.requestDevice(is64 ? { requiredFeatures: ['shader-f64'] } : {});
        const maxBindBytes = device.limits.maxStorageBufferBindingSize ?? (128 * 1024 * 1024);
        maxQ = Math.floor(Math.log2(maxBindBytes / bytesPerAmp));
      }
    }
    for (let q = 1; q <= maxQ; q++) {
      const opt = document.createElement('option');
      opt.value = q;
      opt.textContent = q;
      if (q === 3) opt.selected = true;
      sel.appendChild(opt);
    }
  }

  function setupMobileQubitSelect() {
    const numInput = document.getElementById('numQubits');
    if (!numInput) return;
    const sel = document.createElement('select');
    sel.id = 'numQubits';
    numInput.parentNode.replaceChild(sel, numInput);
    updateNumQubitOptions();
  }

  function setLanguage(lang) {
    currentLang = lang;
    document.getElementById("langSelect").value = lang;
    const t = translations[lang];
    document.title = t.pageTitle;
    document.getElementById('mainTitle').textContent = t.mainTitle;
    document.getElementById('langLabel').textContent = t.langLabel;
    document.getElementById('numLabel').innerHTML = t.numQubitsLabel;
    document.getElementById('precisionLabel').innerHTML = t.precisionLabel;
    document.getElementById('runBtn').textContent = t.runBtn;
    document.getElementById('runBtn').disabled = false;
    document.getElementById('summary').textContent = '';
    document.getElementById('output').textContent = '';
    document.getElementById('precisionMsg').textContent = '';
    if (!runtimeChart) {
      initChart(t);
    } else {
      runtimeChart.options.scales.x.title.text = t.chartXLabel;
      runtimeChart.options.scales.y.title.text = t.chartYLabel;
      runtimeChart.update();
    }
  }

window.addEventListener("error", (e)=>console.error("Window error:", e.error || e.message));

  async function main(numQubits, precision) {
    const out = document.getElementById("output");
    const summary = document.getElementById("summary");
    out.textContent = "";
    summary.textContent = "";
    const t = translations[currentLang];

    const is64 = (precision === "fp64");
    const floatArray = is64 ? Float64Array : Float32Array;
      if (!navigator.gpu) {
        out.textContent = t.notSupported;
        return;
      }

  const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) { out.textContent = t.adapterError; return; }
  if (is64 && !adapter.features.has("shader-f64")) {
    out.textContent = t.fp64NotSupportedError;
    return;
  }
  const device  = await adapter.requestDevice(is64 ? { requiredFeatures: ["shader-f64"] } : {});
  device.onuncapturederror = (e)=>console.error("Uncaptured GPU error:", e.error);

  console.groupCollapsed("🔧 Device Info");
  console.log("Adapter:", adapter);
  console.log("Device Limits:", device.limits);
  console.log("Features:", [...device.features.values()]);
  console.groupEnd();

  const Nstates = 2 ** numQubits;
  const bytesPerAmp = is64 ? 16 : 8; // complex128 or complex64
  const stateBytes  = Nstates * bytesPerAmp;

  const maxBindBytes = device.limits.maxStorageBufferBindingSize ?? (128 * 1024 * 1024);
  const maxQFromBinding = Math.floor(Math.log2(maxBindBytes / bytesPerAmp));
  if (numQubits > maxQFromBinding) {
      out.textContent = t.deviceLimitExceeded(numQubits, maxQFromBinding);
      return;
    }

  console.groupCollapsed("📐 Config");
  console.table({ numQubits, Nstates, stateBytes, maxStorageBufferBindingSize: maxBindBytes, maxQFromBinding });
  console.groupEnd();

  const WG_SIZE = Math.min(256, device.limits.maxComputeInvocationsPerWorkgroup);
  const numPairs = Nstates >>> 1;
  const numWorkgroups = Math.ceil(numPairs / WG_SIZE);

  console.groupCollapsed("🧵 Workgroups");
  console.table({ WG_SIZE, numPairs, numWorkgroups });
  console.groupEnd();

  // --- State vector (ping-pong) ---
  const initHost = new floatArray(Nstates * 2);
  initHost[0] = 1.0;

  const stateA = device.createBuffer({
    size: stateBytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
    mappedAtCreation: true
  });
  new floatArray(stateA.getMappedRange()).set(initHost);
  stateA.unmap();

  const stateB = device.createBuffer({
    size: stateBytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
  });

  const readback = device.createBuffer({
    size: stateBytes, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  });

    const { single: singleQubitWGSL, cnot: cnotWGSL } = await getWGSL(is64, WG_SIZE);
  const singlePipe = device.createComputePipeline({
    layout: "auto", compute: { module: device.createShaderModule({ code: singleQubitWGSL }), entryPoint: "main" }
  });
  const cnotPipe = device.createComputePipeline({
    layout: "auto", compute: { module: device.createShaderModule({ code: cnotWGSL }), entryPoint: "main" }
  });

  // --- Dump (FIX: always pass the result buffer) ---
  async function dumpState(srcBuf, label, maxShow = 8) {
    const enc = device.createCommandEncoder();
    enc.copyBufferToBuffer(srcBuf, 0, readback, 0, stateBytes);
    device.queue.submit([enc.finish()]);
    await device.queue.onSubmittedWorkDone();

    await readback.mapAsync(GPUMapMode.READ);
    const arr = new floatArray(readback.getMappedRange()).slice();
    readback.unmap();

    let norm = 0, nonzero = 0;
    for (let i = 0; i < arr.length; i += 2) {
      const re = arr[i], im = arr[i+1];
      const p = re*re + im*im;
      norm += p;
      if (p > 1e-7) nonzero++;
    }
    const amp0 = [arr[0], arr[1]];
    const lastIdx = (Nstates - 1) * 2;
    const amp1 = [arr[lastIdx], arr[lastIdx + 1]];

    console.groupCollapsed(`🧪 ${label}`);
    console.log(`|0…0⟩ amp: ${fmtC(amp0[0], amp0[1])}, |1…1⟩ amp: ${fmtC(amp1[0], amp1[1])}`);
    console.log(`norm: ${norm.toFixed(8)}, nonzero amplitudes: ${nonzero}`);
    const preview = [];
    for (let i = 0; i < Math.min(Nstates, maxShow); i++) {
      preview.push({ i, bin: padBin(i, numQubits), re: arr[2*i].toFixed(6), im: arr[2*i+1].toFixed(6) });
    }
    console.table(preview);
    console.groupEnd();

    return arr;
  }
  function fmtC(re, im) { const s = im>=0?"+":"−"; return `${re.toFixed(6)} ${s} ${Math.abs(im).toFixed(6)}i`; }
  function padBin(i, n) { return (i>>>0).toString(2).padStart(n,"0"); }

  (function logPairMappingSample() {
    const t = 0, s = 1 << t;
    const preview = [];
    for (let k = 0; k < Math.min(8, numPairs); k++) {
      const block = Math.floor(k / s) * (2 * s);
      const i0 = block + (k % s);
      const i1 = i0 + s;
      preview.push({ k, i0, i1, i0bin: padBin(i0, numQubits), i1bin: padBin(i1, numQubits) });
    }
    console.groupCollapsed("🔎 Pair mapping sample (target=0)");
    console.table(preview);
    console.groupEnd();
  })();

  let bufIn  = stateA;
  let bufOut = stateB;

  const INV_SQRT2 = 1/Math.sqrt(2);
  const H = { a:[+INV_SQRT2,0], b:[+INV_SQRT2,0], c:[+INV_SQRT2,0], d:[-INV_SQRT2,0] };

  // ★ Start timing the simulation section here
  const simT0 = performance.now();               // ← added
  console.time("⏱️ Simulation total");

  // --- H on qubit 0 ---
  {
    console.time("H gate");
    const { buf: uboData, stride, npairs } = buildSingleUBOData(0, Nstates, H);
    console.groupCollapsed("UBO(H) header/matrix");
    console.table({ stride, npairs, a:H.a.join(","), b:H.b.join(","), c:H.c.join(","), d:H.d.join(",") });
    console.groupEnd();

    const ubo = createUBOWithData(device, uboData);

    device.pushErrorScope("validation");
    const enc = device.createCommandEncoder();
    const pass = enc.beginComputePass();
    pass.setPipeline(singlePipe);
    const bind = device.createBindGroup({
      layout: singlePipe.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: bufIn  } },
        { binding: 1, resource: { buffer: bufOut } },
        { binding: 2, resource: { buffer: ubo    } },
      ]
    });
    pass.setBindGroup(0, bind);
    pass.dispatchWorkgroups(numWorkgroups);
    pass.end();
    device.queue.submit([enc.finish()]);
    const err = await device.popErrorScope();
    if (err) console.error("Validation error (H):", err);
    await device.queue.onSubmittedWorkDone();

    if (DEBUG) await dumpState(bufOut, "After H"); // ← FIX: pass the result buffer
    console.timeEnd("H gate");
    [bufIn, bufOut] = [bufOut, bufIn];
  }

  // --- CNOT(0→i), i=1..n-1 ---
  for (let t = 1; t < numQubits; t++) {
    console.time(`CNOT 0→${t}`);
    const { buf: uboData, stride, npairs, controlMask } = buildCNOTUBOData(0, t, Nstates);
    console.groupCollapsed(`UBO(CNOT 0→${t})`);
    console.table({ stride, npairs, controlMask });
    console.groupEnd();

    const ubo = createUBOWithData(device, uboData);

    device.pushErrorScope("validation");
    const enc = device.createCommandEncoder();
    const pass = enc.beginComputePass();
    pass.setPipeline(cnotPipe);
    const bind = device.createBindGroup({
      layout: cnotPipe.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: bufIn  } },
        { binding: 1, resource: { buffer: bufOut } },
        { binding: 2, resource: { buffer: ubo    } },
      ]
    });
    pass.setBindGroup(0, bind);
    pass.dispatchWorkgroups(numWorkgroups);
    pass.end();
    device.queue.submit([enc.finish()]);
    const err = await device.popErrorScope();
    if (err) console.error(`Validation error (CNOT 0→${t}):`, err);
    await device.queue.onSubmittedWorkDone();

    if (DEBUG) await dumpState(bufOut, `After CNOT 0→${t}`); // ← FIX
    console.timeEnd(`CNOT 0→${t}`);
    [bufIn, bufOut] = [bufOut, bufIn];
  }

  console.timeEnd("⏱️ Simulation total");
  const simElapsedMs = performance.now() - simT0;   // ★ Total processing time (for display)

  // --- Final readback to page ---
  const encFinal = device.createCommandEncoder();
  encFinal.copyBufferToBuffer(bufIn, 0, readback, 0, stateBytes);
  device.queue.submit([encFinal.finish()]);
  await device.queue.onSubmittedWorkDone();
  await readback.mapAsync(GPUMapMode.READ);
  const result = new floatArray(readback.getMappedRange()).slice();
  readback.unmap();

  let norm = 0;
  for (let i = 0; i < result.length; i += 2) {
    const re = result[i], im = result[i+1];
    norm += re*re + im*im;
  }
  const amp0Re = result[0], amp0Im = result[1];
  const lastIdx = (Nstates - 1) * 2;
  const amp1Re = result[lastIdx], amp1Im = result[lastIdx + 1];

  const INV_SQRT2_STR = (1/Math.sqrt(2)).toFixed(6);
    summary.innerHTML = t.summary(numQubits, Nstates, amp0Re, amp0Im, amp1Re, amp1Im, norm, simElapsedMs, INV_SQRT2_STR);
    addDataPoint(numQubits, simElapsedMs);
    //  <div class="muted">Check the console (DevTools) for details.</div>

  const lines = [];
  if (numQubits <= 12) {
      lines.push(t.vecHeader);
    for (let i = 0; i < Nstates; i++) {
      lines.push(`${padBin(i, numQubits)} (${i.toString().padStart(4)}) : ` +
                 `${result[2*i].toFixed(6)} + ${result[2*i+1].toFixed(6)}i`);
    }
  } else {
    const threshold = 1e-5;
    const nonzeros = [];
    for (let i = 0; i < Nstates; i++) {
      const re = result[2*i], im = result[2*i+1];
      if (re*re + im*im > threshold*threshold) nonzeros.push([i, re, im]);
    }
      lines.push(t.nonzeroHeader(threshold, nonzeros.length));
    for (const [i, re, im] of nonzeros.slice(0, 32)) {
      lines.push(`${padBin(i, numQubits)} (${i}): ${re.toFixed(6)} + ${im.toFixed(6)}i`);
    }
      if (nonzeros.length > 32) lines.push(t.omitted(nonzeros.length));
    }
  out.textContent = lines.join("\n");
}

/* UI */
  document.getElementById("langSelect").addEventListener("change", (e) => {
    setLanguage(e.target.value);
  });
  if (navigator.language == "ja") {
    setLanguage('ja');
  } else {
    setLanguage('en');
  }
  document.getElementById("precision").addEventListener("change", async (e) => {
    const msg = document.getElementById("precisionMsg");
    msg.textContent = "";
    if (e.target.value === "fp64") {
      const t = translations[currentLang];
      if (!navigator.gpu) {
        msg.textContent = t.notSupported;
        e.target.value = "fp32";
      } else {
        const adapter = await navigator.gpu.requestAdapter();
        if (!adapter) {
          msg.textContent = t.adapterError;
          e.target.value = "fp32";
        } else if (!adapter.features.has("shader-f64")) {
          msg.textContent = t.fp64NotSupportedError;
          e.target.value = "fp32";
        }
      }
    }
    if (isMobile) updateNumQubitOptions();
  });
  if (isMobile) {
    setupMobileQubitSelect();
  }
  const runBtn = document.getElementById("runBtn");
  runBtn.addEventListener("click", async () => {
    document.getElementById("precisionMsg").textContent = "";
    const n = parseInt(document.getElementById("numQubits").value, 10);
    const precision = document.getElementById("precision").value;
    const t = translations[currentLang];
    runBtn.textContent = t.running;
    runBtn.disabled = true;
    try {
      await main(n, precision);
    } finally {
      runBtn.textContent = t.runBtn;
      runBtn.disabled = false;
    }
  });

  // ★ Stop automatic execution (delete the following line)
  // main(parseInt(document.getElementById("numQubits").value, 10));
  </script>
  </body>
  </html>
