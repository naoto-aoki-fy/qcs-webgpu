<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" />
    <title id="pageTitle">WebGPU: GHZ State (State-Vector Simulator with Debug – fixed)</title>
  <style>
    body { font-family: system-ui, sans-serif; line-height: 1.5; padding: 16px; }
    .row { margin-bottom: 12px; }
    input[type="number"] { width: 6em; }
    pre { background: #f7f7f7; padding: 12px; border-radius: 6px; overflow-x: auto; }
    .muted { color:#666; }
  </style>
</head>
  <body>
    <h1 id="mainTitle">WebGPU 量子シミュレータ（GHZ 状態・デバッグ出力つき / 修正版）</h1>
    <div class="row">
      <label id="langLabel" for="langSelect">言語:</label>
      <select id="langSelect">
        <option value="ja">日本語</option>
        <option value="en">English</option>
      </select>
    </div>
    <div class="row">
      <label id="numLabel" for="numQubits">量子ビット数 <code>num_qubits</code>：</label>
      <input id="numQubits" type="number" min="1" value="3">
    </label>
    <label>精度:
      <select id="precision">
        <option value="fp32">FP32</option>
        <option value="fp64">FP64</option>
      </select>
    </label>
    <button id="runBtn">実行</button>
  </div>
  <div id="summary"></div>
  <pre id="output"></pre>

<script type="module">
  const DEBUG = true;
  const UBO_SIZE = 256; // UBO は 256B アライン
  let currentLang = 'ja';

  const translations = {
    ja: {
      pageTitle: 'WebGPU 量子シミュレータ（GHZ 状態・デバッグ出力つき / 修正版）',
      mainTitle: 'WebGPU 量子シミュレータ（GHZ 状態・デバッグ出力つき / 修正版）',
      langLabel: '言語:',
      numQubitsLabel: '量子ビット数 <code>num_qubits</code>：',
      runBtn: '実行',
      notSupported: 'このブラウザは WebGPU をサポートしていません。Chrome/Edge 125+ などでお試しください。',
      adapterError: 'GPU adapter を取得できませんでした。',
      fp64NotSupportedError: "このデバイスは fp64 をサポートしていません。",
      deviceLimitExceeded: (numQubits, maxQFromBinding) => `num_qubits=${numQubits} はデバイス制限（~${maxQFromBinding}）を超えています。`,
      summary: (n, Nstates, amp0Re, amp0Im, amp1Re, amp1Im, norm, simMs, invSqrt2) =>
        `<div>n = <b>${n}</b>（状態次元: 2<sup>${n}</sup> = ${Nstates}）</div>
         <div>⟨0…0|=${amp0Re.toFixed(6)} ${(amp0Im>=0?'+':'−')} ${Math.abs(amp0Im).toFixed(6)}i,
              ⟨1…1|=${amp1Re.toFixed(6)} ${(amp1Im>=0?'+':'−')} ${Math.abs(amp1Im).toFixed(6)}i
              （期待 ~ ${invSqrt2}）</div>
         <div>∥ψ∥² = <b>${norm.toFixed(8)}</b></div>
         <div>合計処理時間（シミュレーション）: <b>${simMs.toFixed(2)} ms</b></div>`,
      vecHeader: '[状態ベクトル（index: re + i·im）]',
      nonzeroHeader: (threshold, count) => `[非ゼロ（しきい値 ${threshold}）: ${count} 個]`,
      omitted: count => `… 省略（合計 ${count} 個）`,
    },
    en: {
      pageTitle: 'WebGPU Quantum Simulator (GHZ State, with Debug Output / fixed)',
      mainTitle: 'WebGPU Quantum Simulator (GHZ State, with Debug Output / fixed)',
      langLabel: 'Language:',
      numQubitsLabel: 'Number of qubits <code>num_qubits</code>:',
      runBtn: 'Run',
      notSupported: 'This browser does not support WebGPU. Please try Chrome/Edge 125+.',
      fp64NotSupportedError: "This device does not support fp64.",
      adapterError: 'Failed to get GPU adapter.',
      deviceLimitExceeded: (numQubits, maxQFromBinding) => `num_qubits=${numQubits} exceeds device limit (~${maxQFromBinding}).`,
      summary: (n, Nstates, amp0Re, amp0Im, amp1Re, amp1Im, norm, simMs, invSqrt2) =>
        `<div>n = <b>${n}</b> (state dimension: 2<sup>${n}</sup> = ${Nstates})</div>
         <div>⟨0…0|=${amp0Re.toFixed(6)} ${(amp0Im>=0?'+':'-')} ${Math.abs(amp0Im).toFixed(6)}i,
              ⟨1…1|=${amp1Re.toFixed(6)} ${(amp1Im>=0?'+':'-')} ${Math.abs(amp1Im).toFixed(6)}i
              (expected ~ ${invSqrt2})</div>
         <div>∥ψ∥² = <b>${norm.toFixed(8)}</b></div>
         <div>Total runtime (simulation): <b>${simMs.toFixed(2)} ms</b></div>`,
      vecHeader: '[State vector (index: re + i·im)]',
      nonzeroHeader: (threshold, count) => `[Non-zero (threshold ${threshold}): ${count} entries]`,
      omitted: count => `... omitted (total ${count} entries)`,
    }
  };

  function setLanguage(lang) {
    currentLang = lang;
    const t = translations[lang];
    document.title = t.pageTitle;
    document.getElementById('mainTitle').textContent = t.mainTitle;
    document.getElementById('langLabel').textContent = t.langLabel;
    document.getElementById('numLabel').innerHTML = t.numQubitsLabel;
    document.getElementById('runBtn').textContent = t.runBtn;
    document.getElementById('summary').textContent = '';
    document.getElementById('output').textContent = '';
  }

window.addEventListener("error", (e)=>console.error("Window error:", e.error || e.message));

  async function main(numQubits, precision) {
    const out = document.getElementById("output");
    const summary = document.getElementById("summary");
    out.textContent = "";
    summary.textContent = "";
    const t = translations[currentLang];

    const is64 = (precision === "fp64");
    const floatArray = is64 ? Float64Array : Float32Array;
      if (!navigator.gpu) {
        out.textContent = t.notSupported;
        return;
      }

  const adapter = await navigator.gpu.requestAdapter();
    if (!adapter) { out.textContent = t.adapterError; return; }
  if (is64 && !adapter.features.has("shader-f64")) {
    out.textContent = t.fp64NotSupportedError;
    return;
  }
  const device  = await adapter.requestDevice(is64 ? { requiredFeatures: ["shader-f64"] } : {});
  device.onuncapturederror = (e)=>console.error("Uncaptured GPU error:", e.error);

  console.groupCollapsed("🔧 Device Info");
  console.log("Adapter:", adapter);
  console.log("Device Limits:", device.limits);
  console.log("Features:", [...device.features.values()]);
  console.groupEnd();

  const Nstates = 2 ** numQubits;
  const bytesPerAmp = is64 ? 16 : 8; // complex128 or complex64
  const stateBytes  = Nstates * bytesPerAmp;

  const maxBindBytes = device.limits.maxStorageBufferBindingSize ?? (128 * 1024 * 1024);
  const maxQFromBinding = Math.floor(Math.log2(maxBindBytes / bytesPerAmp));
  if (numQubits > maxQFromBinding) {
      out.textContent = t.deviceLimitExceeded(numQubits, maxQFromBinding);
      return;
    }

  console.groupCollapsed("📐 Config");
  console.table({ numQubits, Nstates, stateBytes, maxStorageBufferBindingSize: maxBindBytes, maxQFromBinding });
  console.groupEnd();

  const WG_SIZE = Math.min(256, device.limits.maxComputeInvocationsPerWorkgroup);
  const numPairs = Nstates >>> 1;
  const numWorkgroups = Math.ceil(numPairs / WG_SIZE);

  console.groupCollapsed("🧵 Workgroups");
  console.table({ WG_SIZE, numPairs, numWorkgroups });
  console.groupEnd();

  // --- 状態ベクトル（ping-pong） ---
  const initHost = new floatArray(Nstates * 2);
  initHost[0] = 1.0;

  const stateA = device.createBuffer({
    size: stateBytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
    mappedAtCreation: true
  });
  new floatArray(stateA.getMappedRange()).set(initHost);
  stateA.unmap();

  const stateB = device.createBuffer({
    size: stateBytes, usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC
  });

  const readback = device.createBuffer({
    size: stateBytes, usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ
  });

    // --- WGSL（FP32/FP64 切り替え対応） ---
  const scalar = is64 ? "f64" : "f32";
  const complexField = is64 ? `vec2<${scalar}>` : `vec4<${scalar}>`;
  const access = is64 ? "" : ".xy";

  const singleQubitWGSL = /* wgsl */`
struct GateU {
  stride : u32,   // 2^target
  npairs : u32,   // N/2
  _pad0  : u32,
  _pad1  : u32,
  a : ${complexField},${is64 ? "" : "  // [re, im, 0, 0]"}
  b : ${complexField},
  c : ${complexField},
  d : ${complexField},
};

struct Buf { data: array<${scalar}>, };

@group(0) @binding(0) var<storage, read>       stateIn  : Buf;
@group(0) @binding(1) var<storage, read_write> stateOut : Buf;
@group(0) @binding(2) var<uniform>             U       : GateU;

fn cmul(x: vec2<${scalar}>, y: vec2<${scalar}>) -> vec2<${scalar}> {
  return vec2<${scalar}>(x.x*y.x - x.y*y.y, x.x*y.y + x.y*x.x);
}

@compute @workgroup_size(${WG_SIZE})
fn main(@builtin(global_invocation_id) gid : vec3<u32>) {
  let k = gid.x;
  if (k >= U.npairs) { return; }

  let s = U.stride;
  let block = (k / s) * (2u * s);
  let i0    = block + (k % s);
  let i1    = i0 + s;

  let f0 = i0 * 2u;
  let f1 = i1 * 2u;

  let v0 = vec2<${scalar}>(stateIn.data[f0],    stateIn.data[f0+1u]);
  let v1 = vec2<${scalar}>(stateIn.data[f1],    stateIn.data[f1+1u]);

  let a = U.a${access};
  let b = U.b${access};
  let c = U.c${access};
  let d = U.d${access};

  let o0 = cmul(a, v0) + cmul(b, v1);
  let o1 = cmul(c, v0) + cmul(d, v1);

  stateOut.data[f0]    = o0.x;
  stateOut.data[f0+1u] = o0.y;
  stateOut.data[f1]    = o1.x;
  stateOut.data[f1+1u] = o1.y;
}
`;

  const cnotWGSL = /* wgsl */`
struct CNOTU {
  stride      : u32, // 2^target
  npairs      : u32, // N/2
  controlMask : u32, // 2^control
  _pad        : u32,
};

struct Buf { data: array<${scalar}>, };

@group(0) @binding(0) var<storage, read>       stateIn  : Buf;
@group(0) @binding(1) var<storage, read_write> stateOut : Buf;
@group(0) @binding(2) var<uniform>             U       : CNOTU;

@compute @workgroup_size(${WG_SIZE})
fn main(@builtin(global_invocation_id) gid : vec3<u32>) {
  let k = gid.x;
  if (k >= U.npairs) { return; }

  let s = U.stride;
  let block = (k / s) * (2u * s);
  let i0    = block + (k % s);
  let i1    = i0 + s;

  let f0 = i0 * 2u;
  let f1 = i1 * 2u;

  if ((i0 & U.controlMask) != 0u) {
    // swap
    stateOut.data[f0]    = stateIn.data[f1];
    stateOut.data[f0+1u] = stateIn.data[f1+1u];
    stateOut.data[f1]    = stateIn.data[f0];
    stateOut.data[f1+1u] = stateIn.data[f0+1u];
  } else {
    // copy
    stateOut.data[f0]    = stateIn.data[f0];
    stateOut.data[f0+1u] = stateIn.data[f0+1u];
    stateOut.data[f1]    = stateIn.data[f1];
    stateOut.data[f1+1u] = stateIn.data[f1+1u];
  }
}
`;
const singlePipe = device.createComputePipeline({
    layout: "auto", compute: { module: device.createShaderModule({ code: singleQubitWGSL }), entryPoint: "main" }
  });
  const cnotPipe = device.createComputePipeline({
    layout: "auto", compute: { module: device.createShaderModule({ code: cnotWGSL }), entryPoint: "main" }
  });

  // --- UBO helpers（FIX: usage に COPY_DST を含める） ---
  function createUBOWithData(arrayBuffer) {
    const ubo = device.createBuffer({
      size: UBO_SIZE,
      usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST
    });
    device.queue.writeBuffer(ubo, 0, arrayBuffer);
    return ubo;
  }

  function buildSingleUBOData(target, N, mat) {
    const buf = new ArrayBuffer(UBO_SIZE);
    const dv  = new DataView(buf);
    const stride = 1 << target;
    const npairs = N >>> 1;

    dv.setUint32(0,  stride, true);
    dv.setUint32(4,  npairs, true);
    dv.setUint32(8,  0, true);
    dv.setUint32(12, 0, true);

    if (is64) {
      const f64 = new Float64Array(buf);
      let base = 16 / 8;
      f64[base+0] = mat.a[0]; f64[base+1] = mat.a[1];
      f64[base+2] = mat.b[0]; f64[base+3] = mat.b[1];
      f64[base+4] = mat.c[0]; f64[base+5] = mat.c[1];
      f64[base+6] = mat.d[0]; f64[base+7] = mat.d[1];
    } else {
      const f32 = new Float32Array(buf);
      let base = 16 / 4; // float index
      // a,b,c,d（xy に re,im / zw=0）
      f32[base+0]  = mat.a[0]; f32[base+1]  = mat.a[1];
      f32[base+4]  = mat.b[0]; f32[base+5]  = mat.b[1];
      f32[base+8]  = mat.c[0]; f32[base+9]  = mat.c[1];
      f32[base+12] = mat.d[0]; f32[base+13] = mat.d[1];
    }

    return { buf, stride, npairs };
  }

  function buildCNOTUBOData(control, target, N) {
    const buf = new ArrayBuffer(UBO_SIZE);
    const dv  = new DataView(buf);
    const stride = 1 << target;
    const npairs = N >>> 1;
    const controlMask = 1 << control;

    dv.setUint32(0,  stride, true);
    dv.setUint32(4,  npairs, true);
    dv.setUint32(8,  controlMask, true);
    dv.setUint32(12, 0, true);

    return { buf, stride, npairs, controlMask };
  }

  // --- ダンプ（FIX: いつも「計算結果バッファ」を渡す） ---
  async function dumpState(srcBuf, label, maxShow = 8) {
    const enc = device.createCommandEncoder();
    enc.copyBufferToBuffer(srcBuf, 0, readback, 0, stateBytes);
    device.queue.submit([enc.finish()]);
    await device.queue.onSubmittedWorkDone();

    await readback.mapAsync(GPUMapMode.READ);
    const arr = new floatArray(readback.getMappedRange()).slice();
    readback.unmap();

    let norm = 0, nonzero = 0;
    for (let i = 0; i < arr.length; i += 2) {
      const re = arr[i], im = arr[i+1];
      const p = re*re + im*im;
      norm += p;
      if (p > 1e-7) nonzero++;
    }
    const amp0 = [arr[0], arr[1]];
    const lastIdx = (Nstates - 1) * 2;
    const amp1 = [arr[lastIdx], arr[lastIdx + 1]];

    console.groupCollapsed(`🧪 ${label}`);
    console.log(`|0…0⟩ amp: ${fmtC(amp0[0], amp0[1])}, |1…1⟩ amp: ${fmtC(amp1[0], amp1[1])}`);
    console.log(`norm: ${norm.toFixed(8)}, nonzero amplitudes: ${nonzero}`);
    const preview = [];
    for (let i = 0; i < Math.min(Nstates, maxShow); i++) {
      preview.push({ i, bin: padBin(i, numQubits), re: arr[2*i].toFixed(6), im: arr[2*i+1].toFixed(6) });
    }
    console.table(preview);
    console.groupEnd();

    return arr;
  }
  function fmtC(re, im) { const s = im>=0?"+":"−"; return `${re.toFixed(6)} ${s} ${Math.abs(im).toFixed(6)}i`; }
  function padBin(i, n) { return (i>>>0).toString(2).padStart(n,"0"); }

  (function logPairMappingSample() {
    const t = 0, s = 1 << t;
    const preview = [];
    for (let k = 0; k < Math.min(8, numPairs); k++) {
      const block = Math.floor(k / s) * (2 * s);
      const i0 = block + (k % s);
      const i1 = i0 + s;
      preview.push({ k, i0, i1, i0bin: padBin(i0, numQubits), i1bin: padBin(i1, numQubits) });
    }
    console.groupCollapsed("🔎 Pair mapping sample (target=0)");
    console.table(preview);
    console.groupEnd();
  })();

  let bufIn  = stateA;
  let bufOut = stateB;

  const INV_SQRT2 = 1/Math.sqrt(2);
  const H = { a:[+INV_SQRT2,0], b:[+INV_SQRT2,0], c:[+INV_SQRT2,0], d:[-INV_SQRT2,0] };

  // ★ ここからシミュレーション区間の計測を開始
  const simT0 = performance.now();               // ← 追加
  console.time("⏱️ Simulation total");

  // --- H on qubit 0 ---
  {
    console.time("H gate");
    const { buf: uboData, stride, npairs } = buildSingleUBOData(0, Nstates, H);
    console.groupCollapsed("UBO(H) header/matrix");
    console.table({ stride, npairs, a:H.a.join(","), b:H.b.join(","), c:H.c.join(","), d:H.d.join(",") });
    console.groupEnd();

    const ubo = createUBOWithData(uboData);

    device.pushErrorScope("validation");
    const enc = device.createCommandEncoder();
    const pass = enc.beginComputePass();
    pass.setPipeline(singlePipe);
    const bind = device.createBindGroup({
      layout: singlePipe.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: bufIn  } },
        { binding: 1, resource: { buffer: bufOut } },
        { binding: 2, resource: { buffer: ubo    } },
      ]
    });
    pass.setBindGroup(0, bind);
    pass.dispatchWorkgroups(numWorkgroups);
    pass.end();
    device.queue.submit([enc.finish()]);
    const err = await device.popErrorScope();
    if (err) console.error("Validation error (H):", err);
    await device.queue.onSubmittedWorkDone();

    if (DEBUG) await dumpState(bufOut, "After H"); // ← FIX: 計算結果バッファを渡す
    console.timeEnd("H gate");
    [bufIn, bufOut] = [bufOut, bufIn];
  }

  // --- CNOT(0→i), i=1..n-1 ---
  for (let t = 1; t < numQubits; t++) {
    console.time(`CNOT 0→${t}`);
    const { buf: uboData, stride, npairs, controlMask } = buildCNOTUBOData(0, t, Nstates);
    console.groupCollapsed(`UBO(CNOT 0→${t})`);
    console.table({ stride, npairs, controlMask });
    console.groupEnd();

    const ubo = createUBOWithData(uboData);

    device.pushErrorScope("validation");
    const enc = device.createCommandEncoder();
    const pass = enc.beginComputePass();
    pass.setPipeline(cnotPipe);
    const bind = device.createBindGroup({
      layout: cnotPipe.getBindGroupLayout(0),
      entries: [
        { binding: 0, resource: { buffer: bufIn  } },
        { binding: 1, resource: { buffer: bufOut } },
        { binding: 2, resource: { buffer: ubo    } },
      ]
    });
    pass.setBindGroup(0, bind);
    pass.dispatchWorkgroups(numWorkgroups);
    pass.end();
    device.queue.submit([enc.finish()]);
    const err = await device.popErrorScope();
    if (err) console.error(`Validation error (CNOT 0→${t}):`, err);
    await device.queue.onSubmittedWorkDone();

    if (DEBUG) await dumpState(bufOut, `After CNOT 0→${t}`); // ← FIX
    console.timeEnd(`CNOT 0→${t}`);
    [bufIn, bufOut] = [bufOut, bufIn];
  }

  console.timeEnd("⏱️ Simulation total");
  const simElapsedMs = performance.now() - simT0;   // ★ 合計処理時間（表示用）

  // --- Final readback to page ---
  const encFinal = device.createCommandEncoder();
  encFinal.copyBufferToBuffer(bufIn, 0, readback, 0, stateBytes);
  device.queue.submit([encFinal.finish()]);
  await device.queue.onSubmittedWorkDone();
  await readback.mapAsync(GPUMapMode.READ);
  const result = new floatArray(readback.getMappedRange()).slice();
  readback.unmap();

  let norm = 0;
  for (let i = 0; i < result.length; i += 2) {
    const re = result[i], im = result[i+1];
    norm += re*re + im*im;
  }
  const amp0Re = result[0], amp0Im = result[1];
  const lastIdx = (Nstates - 1) * 2;
  const amp1Re = result[lastIdx], amp1Im = result[lastIdx + 1];

  const INV_SQRT2_STR = (1/Math.sqrt(2)).toFixed(6);
    summary.innerHTML = t.summary(numQubits, Nstates, amp0Re, amp0Im, amp1Re, amp1Im, norm, simElapsedMs, INV_SQRT2_STR);
    //  <div class="muted">詳細はコンソール（DevTools）をご確認ください。</div>

  const lines = [];
  if (numQubits <= 12) {
      lines.push(t.vecHeader);
    for (let i = 0; i < Nstates; i++) {
      lines.push(`${padBin(i, numQubits)} (${i.toString().padStart(4)}) : ` +
                 `${result[2*i].toFixed(6)} + ${result[2*i+1].toFixed(6)}i`);
    }
  } else {
    const threshold = 1e-5;
    const nonzeros = [];
    for (let i = 0; i < Nstates; i++) {
      const re = result[2*i], im = result[2*i+1];
      if (re*re + im*im > threshold*threshold) nonzeros.push([i, re, im]);
    }
      lines.push(t.nonzeroHeader(threshold, nonzeros.length));
    for (const [i, re, im] of nonzeros.slice(0, 32)) {
      lines.push(`${padBin(i, numQubits)} (${i}): ${re.toFixed(6)} + ${im.toFixed(6)}i`);
    }
      if (nonzeros.length > 32) lines.push(t.omitted(nonzeros.length));
    }
  out.textContent = lines.join("\n");
}

/* UI */
  document.getElementById("langSelect").addEventListener("change", (e) => {
    setLanguage(e.target.value);
  });
  setLanguage('ja');
document.getElementById("runBtn").addEventListener("click", async () => {
  const n = parseInt(document.getElementById("numQubits").value, 10);
  const precision = document.getElementById("precision").value;
  await main(n, precision);
});

  // ★ 自動実行をやめる（以下の行を削除）
  // main(parseInt(document.getElementById("numQubits").value, 10));
  </script>
  </body>
  </html>
